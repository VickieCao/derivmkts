%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{derivmkts Package Overview}
\documentclass{article}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{listings}
\usepackage[linktocpage=TRUE, colorlinks=TRUE]{hyperref}
\usepackage{natbib}
    \lstset{
    language=R,
    tabsize=2,
    keepspaces,
    extendedchars=true,
    rulecolor=\color{black},
    basicstyle=\footnotesize\ttfamily,
    aboveskip=5pt,
    upquote=true,
    columns=fixed,
    showstringspaces=false,
    extendedchars=true,
    breaklines=true,
    frame=none,
    showtabs=true,
    showspaces=false,
    showstringspaces=false,
}

\title{Option Pricing Functions to Accompany \emph{Derivatives Markets}}
\author{Robert McDonald}
\date{\today}

\lstMakeShortInline{|}

<<echo=FALSE, message=FALSE, warning=FALSE>>=
library(highlight)
library(knitr)
##homedir <- '/home/rmcd/tex/d67/Rtutorial/'
options(digits=4)
figsize <- 4.5
opts_chunk$set(size='footnotesize', prompt=FALSE, comment=NA,
               fig.align='center', fig.width = figsize,
               fig.height=figsize, out.width='3.75in')

#              , fig.width=4.5*3.75/3.25, fig.height=4.5,
#              , out.width='3.75in', out.height='3.25in'
#               )
opts_knit$set(highlight = TRUE,
              eval.after='fig.cap',
              prompt=TRUE,
              renderer=renderer_latex(document=FALSE),
              size='footnotesize')
@


\begin{document}
\maketitle
\tableofcontents


<<echo=FALSE>>=
library(derivmkts)
library(markdown)

opts_chunk$set(collapse=TRUE)
@

\section{Introduction}

This vignette is an overview to the functions in the \emph{derivmkts}
package, which was conceived as a companion to my book
\emph{Derivatives Markets} \citep{mcdonald:derivs:13}. The material
has an educational focus. There are other option pricing packages for
R, but this package has several distinguishing features:
\begin{itemize}
\item function names (mostly) correspond to those in \emph{Derivatives
  Markets}.
\item vectorized Greek calculations are convenient both for individual
  options and for portfolios
\item the |quincunx| function illustrates the workings of a
  quincunx (Galton board).
\item binomial functions include a plotting function that provides a
  visual depiction of early exercise
\end{itemize}



\section{European Calls and Puts}


Table \ref{tab:bslist} lists the Black-Scholes related functions in
the package.  The functions |bscall|, |bsput|, and |bsopt| provide
basic pricing of European calls and puts. There are also options with
binary payoffs: cash-or-nothing and asset-or-nothing options. All of
these functions are vectorized. The function |bsopt| by default
provides option greeks. Here are some examples:

<<>>=
s <- 100; k <- 100; r <- 0.08; v <- 0.30; tt <- 2; d <- 0
bscall(s, k, v, r, tt, d)
bsput(s, c(95, 100, 105), v, r, tt, d)

@


\begin{table}[btp]
  \centering
  \begin{tabular}{cp{4in}}
    Function& Description \\ \hline
    bscall & European call\\
    bsput & European put\\
    bsopt & European call and put and associated Greeks: delta, gamma,
            vega, theta, rho, psi, and elasticity \\
    assetcall &  Asset-or-nothing call\\
    assetput &  Asset-or-nothing put\\
    cashcall &  Cash-or-nothing call\\
    cashput & Cash-or-nothing put
  \end{tabular}
  \caption{Black-Scholes related option pricing functions}
  \label{tab:bslist}
\end{table}

\section{Barrier Options}

There are pricing functions for the following barrier options:

\begin{itemize}
\item down-and-in and down-and-out barrier binary options
\item  up-and-in and up-and-out barrier binary options
\item  more standard
  down- and up- calls and puts, constructed using the barrier binary
  options
\end{itemize}
Naming for the barrier options generally follows the convention
\begin{verbatim}
[u|d][i|o][call|put]
\end{verbatim}
which means that the option is ``up'' or ``down'', ``in'' or ``out'', and a
call or put.\footnote{This naming convention differs from that in
  \emph{Derivatives Markets}, in which names are \lstinline{callupin},
  \lstinline{callupout}, etc. Thus, I have made both names are
  available for these functions.}  An up-and-in call, for example,
would be denoted by |uicall|. For binary options, we add the
underlying, which is either the asset or \$1: cash:

\begin{verbatim}
[asset|cash][u|d][i|o][call|put]
\end{verbatim}


<<>>=
H <- 115
bscall(s, c(80, 100, 120), v, r, tt, d)
uicall(s, c(80, 100, 120), v, r, tt, d, H)
bsput(s, c(80, 100, 120), v, r, tt, d)
uoput(s, c(80, 100, 120), v, r, tt, d, H)
@

\section{Perpetual American Options}

The functions \lstinline{callperpetual} and \lstinline{putperetual}
price infinitely-lived American options. The pricing formula assumes
that all inputs (risk-free rate, volatility, dividend yield) are
fixed. This is of course usual with the basic option pricing formulas,
but it is more of a conceptual stretch for an infinitely-lived option
than for a 3-month option.  

In order for the option to have a determined value, the dividend yield
on the underlying asset must be positive if the option is a call. If
this is not true, the call is never exercised and the price is
undefined.\footnote{A well-known result \citep{merton:73-bell} is that
  a standard American call is never exercised before expiration if the
  dividend yield is zero and the interest rate is non-negative. A
  perpetual call with $\delta=0$ and $r>0$ would thus never be
  exercised. The limit of the option price as $\delta\to 0$ is $s$, so
  in this case the function returns the stock price as the option
  value.} Similarly, the risk-free rate must be positive if the option
is a put.

By default, the perpetual pricing formulas return the price. By
setting \lstinline{showbarrier=TRUE}, the function returns both the option price
and the stock price at which the option is optimally exercised (the
``barrier'').  Here are some examples:
<<>>=
s <- 100; k <- 100; r <- 0.08; v <- 0.30; tt <- 2; d <- 0.04
callperpetual(s, c(95, 100, 105), v, r, d)
callperpetual(s, c(95, 100, 105), v, r, d, showbarrier=TRUE)

@ 

\section{Option Greeks}

Greeks for vanilla and barrier options can be computed using the
|greeks| function, which is a wrapper for any pricing function that
returns the option price and which uses the default naming of
inputs.\footnote{In this version of the package, I have two
  alternative functions that return Greeks:
  \begin{itemize}
  \item The \lstinline{bsopt} function by default
    produces prices and Greeks for European calls and puts.
\item The \lstinline{greeks2} function takes as arguments the name of the pricing
  function and then inputs as a list.
\end{itemize}
These may be deprecated in the future. \lstinline{greeks2} is
more cumbersome to use but may be more robust. I welcome feedback on
these functions and what you find useful.
}

<<>>=
H <- 105
greeks(uicall(s, k, v, r, tt, d, H))

@

The value of this approach is that you can easily compute Greeks for
spreads and custom pricing functions. Here are two examples. First,
the value at time 0 of a prepaid contract that pays $S_{T}^{a}$ at
time $T$ is given by the \lstinline{powercontract()} function:
<<>>=
powercontract <- function(s, v, r, tt, d, a) {
    price <- exp(-r*tt)*s^a* exp((a*(r-d) + 1/2*a*(a-1)*v^2)*tt)
}
@ 

We can easily compute the Greeks for a power contract:
<<>>=
greeks(powercontract(s=40, v=.08, r=0.08, tt=0.25, d=0, a=2))
@

Second, consider a bull spread in which we buy a call with a strike of
$k_{1}$ and sell a call with a strike of $k_2$. We can create a
function that computes the
value of the spread, and then  compute the greeks for the spread by
using this newly-created function together with \lstinline{greeks()}:
<<>>=
bullspread <- function(s, v, r, tt, d, k1, k2) {
    bscall(s, k1, v, r, tt, d) - bscall(s, k2, v, r, tt, d)
}
greeks(bullspread(39:41, .3, .08, 1, 0, k1=40, k2=45))

@

The Greeks function is vectorized, so you can create vectors of greek
values with a single call. This example plots, for a bull spread, the
gamma as a function of the stock price; see Figure \ref{fig:bullgamma}.
<<bullgamma, fig.cap='Gamma for a 40-45 bull spread.'>>=
sseq <- seq(1, 100, by=0.5)
x <- greeks(bullspread(sseq, .3, .08, 1, 0, k1=40, k2=45))
plot(sseq, x['Gamma',], type='l')

@


This code produces the plots in Figure \ref{fig:allgreeks}:
%%As an alternative, the |bsopt| function provides all option Greeks,
%%vectorized, for both puts and calls. See Figure \ref{fig:allgreeks}.
<<allgreeks, fig.cap='All option Greeks, computed using the greeks() function', fig.width=7.5, fig.height=6.5>>=
k <- 100; r <- 0.08; v <- 0.30; tt <- 2; d <- 0
S <- seq(.5, 250, by=.5)
Call <- greeks(bscall(S, k, v, r, tt, d))
Put <- greeks(bsput(S, k, v, r, tt, d))
y <- list(Call=Call, Put=Put)
par(mfrow=c(4, 4))  ## create a 4x4 plot
par(mar=c(2,2,2,2))
for (i in names(y)) {
    for (j in rownames(y[[i]])) {  ## loop over greeks
        plot(S, y[[i]][j, ], main=paste(i, j), ylab=j, type='l')
    }
}

@


\section{Binomial Pricing of European and American Options}

There are two functions related to binomial option pricing:
\begin{description}
\item[binomopt] computes prices of American and European calls and
  puts. The function has three optional parameters that control output:
  \begin{itemize}
  \item \lstinline{returnparams=TRUE} will return as a vector the option
    pricing inputs, computed parameters, and risk-neutral probability.
    
  \item \lstinline{returngreeks=TRUE} will return as a vector the price,
    delta, gamma, and theta at the initial node.
  \item \lstinline{returntrees=TRUE} will return as a list the price,
    greeks, the full  stock price tree, the exercise status
    (\lstinline{TRUE} or \lstinline{FALSE}) at each node, and the
    replicating portfolio at each node.
  \end{itemize}
  
\item[binomplot] displays the asset price
  tree, the corresponding probability of being at each node, and
  whether or not the option is exercised at each node. This
  function is described in more detail in Section \ref{sec:binomplot}.
\end{description}

Here are examples of pricing, illustrating the default of just
returning the price, and the ability to return the price plus
parameters, as well as the price, the parameters, and various trees:

<<>>=
s <- 100; k <- 100; r <- 0.08; v <- 0.30; tt <- 2; d <- 0.03
binomopt(s, k, v, r, tt, d, nstep=3)
binomopt(s, k, v, r, tt, d, nstep=3, returnparams=TRUE)
binomopt(s, k, v, r, tt, d, nstep=3, putopt=TRUE)
binomopt(s, k, v, r, tt, d, nstep=3, returntrees=TRUE, putopt=TRUE)
@



\section{Asian Options}

There are analytical functions for valuing geometric Asian options and
Monte Carlo routines for valuing arithmetic Asian options. Be aware
that the \lstinline{greeks()} function at this time will not work
automatically with geometric Asian options nor (for different reasons)
with arithmetic Asian options. I plan to address this in a future
release.\footnote{At this time the \lstinline{greeks()} function will
  not work with options valued using Monte Carlo. The reason is that
  each invocation of the pricing function will start with a different
  random number seed, resulting in some price variation that is due
  solely to random variation. Random number generation and setting the
  seed is a global change. In a future release I hope to address this
  by saving and restoring the seed within the greeks function. For the
  curious,
  \href{http://stackoverflow.com/questions/14324096/setting-seed-locally-not-globally-in-r}{a
    Stackoverflow post} discusses this issue.}

\subsection{Geometric Asian Options}

Geometric Asian options can be valued using the Black-Scholes formulas
for vanilla calls and puts, with modified inputs. The functions return
both call and put prices with a named vector:

<<>>=
s <- 100; k <- 100; r <- 0.08; v <- 0.30; tt <- 2; d <- 0.03; m <- 3
geomavgpricecall(s, 98:102, v, r, tt, d, m)
geomavgpricecall(s, 98:102, v, r, tt, d, m, cont=TRUE)
geomavgstrikecall(s, k, v, r, tt, d, m)

@ 


\subsection{Arithmetic Asian Options}

Monte Carlo valuation is used to price arithmetic Asian options. For
efficiency, the function \lstinline{arithasianmc} returns call and put
prices for average price and average strike options. By default the
number of simulations is 1000. Optionally the function returns the
standard deviation of each estimate

<<>>=
arithasianmc(s, k, v, r, tt, d, 3, numsim=5000, printsds=TRUE)

@ 

The function \lstinline{arithavgpricecv} uses the control variate
method to reduce the variance in the simulation. At the moment this
function prices only calls, and returns both the price and the
regression coefficient used in the control variate correction:

<<>>=
arithavgpricecv(s, k, v, r, tt, d, 3, numsim=5000)

@ 
\section{Jumps and Stochastic Volatility}
\label{sec:jumps}

The \lstinline{mertonjump} function returns call and put prices for a
stock that can jump discretely. A poisson process controls the
occurrence of a jump and the size of the jump is lognormally
distributed. The parameter \lstinline{lambda} is the mean number of
jumps per year,  the parameter \lstinline{alphaj} is the log of the
expected jump, and \lstinline{sigmaj} is the standard deviation of the
log of the jump. The jump amount is thus drawn from the distribution
\begin{equation*}
  Y \sim \mathcal{N}(\alpha_{J} - 0.5\sigma^{2}_{J}, \sigma_{J}^{2} )
\end{equation*}

<<>>=
mertonjump(s, k, v, r, tt, d, lambda=0.5, alphaj=-0.2, vj=0.3)
c(bscall(s, k, v, r, tt, d), bsput(s, k, v, r, tt, d))
@ 

\section{Bonds}

The simple bond functions provided in this version compute the present
value of cash flows (|bondpv|), the IRR of the bond (|bondyield|),
Macaulay duration (|duration|), and convexity (|convexity|).

<<>>=
coupon <- 8; mat <- 20; yield <- 0.06; principal <- 100; 
modified <- FALSE; freq <- 2
price <- bondpv(coupon, mat, yield, principal, freq)
price
bondyield(price, coupon, mat, principal, freq)
duration(price, coupon, mat, principal, freq, modified)
convexity(price, coupon, mat, principal, freq)

@ 



\section{Functions with Graphical Output}


Several functions provide visual illustrations of some aspects of the
material.

\subsection{Quincunx or Galton Board}

The quincunx is a physical device the illustrates the central limit
theorem. A ball rolls down a pegboard and strikes a peg, falling
randomly either to the left or right. As it continues down the board
it continues to strike a series of pegs, randomly falling left or
right at each. The balls
collect in bins and create an approximate normal distribution. 

The quincunx function allows the user to simulate a quincunx,
observing the path of each ball and watching the height of each bin as
the balls accumulate. More interestingly, the quincunx function
permits altering the probability that the ball will fall to the
right. 

Figure \ref{fig:quincunx} illustrates the function after dropping 200
balls down 20 levels of pegs with a 70\% probability that each ball
will fall right:

<<quincunx, fig.cap='Output from the Quincunx function'>>=
par(mar=c(2,2,2,2))
quincunx(n=20, numballs=200, delay=0, probright=0.7)
@ 

\subsection{Plotting the Solution to the Binomial Pricing Model}
\label{sec:binomplot}

The |binomplot| function calls |binomopt| to compute the option price
and the various trees, which it then uses in plotting:

The first plot, figure \ref{fig:binomplot1}, is basic:

<<binomplot1, fig.cap='Basic option plot showing stock prices and nodes at which the option is exercised.\\label{fig:binomplot1}'>>=
binomplot(s, k, v, r, tt, d, nstep=6, american=TRUE, putopt=TRUE)

@

The second plot, figure \ref{fig:binomplot2}, adds a display of stock
prices and arrows connecting the nodes.

<<binomplot2, fig.cap='Same plot as Figure \\ref{fig:binomplot1} except that values and arrows are added to the plot.\\label{fig:binomplot2}'>>=
binomplot(s, k, v, r, tt, d, nstep=6, american=TRUE, putopt=TRUE,
    plotvalues=TRUE, plotarrows=TRUE)
@

As a final example, consider an American call when the dividend yield
is positive and |nstep| has a larger value. Figure
\ref{fig:binomplot3} shows the plot, with early exercise evident.

<<binomplot3, fig.cap="Binomial plot when nstep is 40.\\label{fig:binomplot3}">>=
d <- 0.06
binomplot(s, k, v, r, tt, d, nstep=40, american=TRUE)
@

The large value of |nstep| creates a high maximum terminal stock
price, which makes details hard to discern in the boundary region
where exercise first occurrs. We can zoom in on that region by
selecting values for |ylimval|; the result is in Figure \ref{fig:binomplot4}.

<<binomplot4, fig.cap="Binomial plot when nstep is 40 using the argument ylimval to focus on a subset.\\label{fig:binomplot4}">>=
d <- 0.06
binomplot(s, k, v, r, tt, d, nstep=40, american=TRUE, ylimval=c(75, 225))
@

\clearpage

\appendix
%\section{Appendices}

\section{Vectorization}

Where possible, I have tried to make sure that the pricing functions
return vectors. This is automatic in many cases (for example, with the
Black-Scholes formula), but there are situations in which achieving
robust vectorization requires care when constructing a function. The
purpose of this section is to explain the problems I encountered and
the solutions I considered. Perhaps I overlooked the obvious or I am
ignorant of some details of R. In either case I hope you will let me
know! Otherwise, I hope this discussion is helpful to others.

\subsection{Automatic Vectorization}

<<>>=
f = function(a, b, k) a*b + k
f(3, 5, 1) 
f(1:5, 5, 1) 
f(1:6, 1:2, 1) 
@ 

In this example, R automatically vectorizes the multiplication using
the recycling rule. It's worth noting that the third example, in which
both arguments are vectorized, but with different length vectors, is
an unusual programming construct.\footnote{You can produce the same
  output in python using the itertools module.} This property makes it
trivial to perform what-if calculations for an option pricing formula.

\subsection{Limitations of Automatic Vectorization}

A problem with automatic vectorization occurs when there are
conditional statements. With barrier options, for example, it is
necessary to check whether the asset price is past the barrier. R's
\lstinline{if} statement is not vectorized, and the
\lstinline{ifelse} function returns output that has the dimension of
the conditional. 

<<>>=
cond1 <- function(a, b, k) {
    if (a > b) {
        a*b + k
    } else {
        k
    }
}
cond1(5, 3, 1)
cond1(5, 7, 1)
cond1(3:7, 5, 1)

@ 

The third invocation of \lstinline{cond1} causes an error because the
\lstinline{if} statement is not vectorized. This can be fixed by
rewriting the conditional using \lstinline{ifelse}, which is
vectorized. The following examples all compute correctly because if
either $a$ or $b$ are vectors, the conditional statement is
vectorized:

<<>>=
cond2 <- function(a, b, k) {
    ifelse(a > b, 
           a*b + k,  
           k
           )
}
cond2(5, 3, 1)
cond2(5, 7, 1)
cond2(3:7, 5, 1)

@ 

There will, however, be a problem if only $k$ is a vector.  Suppose we
set $a=5$, $b=7$, $k=1:3$. Because $a < b$, we want to produce the
output $1, 2, 3$. The following example does not work as desired
because neither of the variables in the conditional ($a$ and $b$) are
a vector. Thus the calculation is not vectorized:
<<>>=
cond2(5, 7, 1:3)
@ 

The \lstinline{ifelse} function returns output with the dimension of
the conditional expression, which in this case is a vector of length
1.

\subsection{Three Solutions}

One solution is to write the function so as to vectorize all the
inputs to match the vector length of the longest input. There are at
least three ways to do this.

\subsubsection{Use a Booleans in Place of \lstinline{ifelse}}

We can create a boolean variable that is true if $a > b$. This will
then control which expression is returned:

<<>>=
cond2b <- function(a, b, k) {
    agtb <- (a > b)
    agtb*(a*b + k) + (1-agtb)*k
}

cond2b(5, 3, 1)
cond2b(5, 7, 1)
cond2b(3:7, 5, 1)
cond2b(5, 7, 1:3)

@ 

Whether this solution works in other functions depends on the
structure of the calculation and the nature of the output. In
particular, if the value of a boolean controls the  data structure
the function returns (a vector vs a list, for example), then this
solution does not work.

\subsubsection{Create a Data Frame}

We can enforce the recycling rule for all variables by creating a data
frame consisting of the inputs and assigning the columns back to the
original variables:

<<>>=
cond2c <- function(a, b, k) {
    tmp <- data.frame(a, b, k)
    for (i in names(tmp)) assign(i, tmp[[i]])
    ifelse(a > b, 
           a*b + k,  
           k
           )
}

cond2c(5, 3, 1)
cond2c(5, 7, 1)
cond2c(3:7, 5, 1)
cond2c(5, 7, 1:3)

@ 

One drawback of this solution is that we have to be careful to update
the \lstinline{data.frame()} definition within the function if we
change the function inputs. It may be easy to overlook this when
editing the function. The next solution is a more robust version of
the same idea.

\subsubsection{Create a Vectorization Function}

A final alternative is to create a vectorization function that
exploits R's functional capabilities and does not require
modifications if the function definition changes. This approach can
become quite complicated, but is relatively easy to understand in
simple cases. We create a \lstinline{vectorizeinputs()} function that
creates a data frame and vectorizes all variables:

<<>>=
vectorizeinputs <- function(e) {
    ## e is the result of match.call() in the calling function
    e[[1]] <- NULL
    e <- as.data.frame(as.list(e))
    for (i in names(e)) assign(i, eval(e[[i]]),
                               envir=parent.frame())
}
@ 

This function assumes that \lstinline{match.call()} has been invoked
in the calling function. The result of that invocation is manipulated
to provide information about the parameters passed to the function and
used to create the data frame and pass the variables back to the
calling function.

<<>>=
cond3 <- function(a, b, k) { 
    vectorizeinputs(match.call())
    ifelse(a > b, a*b + k, k)
}
cond3(5, 7, 1:3)
cond3(3:7, 5, 1)
cond3(3:7, 5, 1:5)
cond3(k=1:5, 3:7, 5)

@ 

This approach becomes more complicated if there are implicit
parameters in the function. If truly implicit, these will not be
available via \lstinline{match.call()}, but they can affect the
solution. Here is an example:

<<>>=
cond4 <- function(a, b, k, multby2=TRUE) {
    vectorizeinputs(match.call())
    ifelse(multby2, 
           2*(a*b + k), 
           a*b + k
           )
}
cond4(5, 7, 1:3)
cond4(3:7, 5, 1)
cond4(3:7, 5, 1:5)
cond4(k=1:5, 3:7, 5)

@ 

The output is not vectorized because the implicit parameter
\lstinline{multby2} is implicit --- it is not explicit in the function
call --- and therefore it is not vectorized. One way to handle this
case is to rewrite the \lstinline{vectorizeinputs} function to
retrieve the full set of function inputs for the called function.
The name of the function is available through
\lstinline{match.call()[[1]]}, and the function parameters are
available using the \lstinline{formals} function. We can then add the
implicit parameters to the vectorized set of inputs. The function
\lstinline{vectorizeinputs2} takes this approach:

<<>>=
vectorizeinputs2 <- function(e) {
    funcname <- e[[1]]
    fvals <- formals(eval(funcname))
    fnames <- names(fvals)
    e[[1]] <- NULL
    e <- as.data.frame(as.list(e))
    implicit <- setdiff(fnames, names(e))
    if (length(implicit) > 0) e <- data.frame(e, fvals[implicit])
    for (i in names(e)) assign(i, eval(e[[i]]),
                               envir=parent.frame())
}

cond5 <- function(a, b, k, multby2=TRUE, altmult=1) {
    vectorizeinputs2(match.call())
    ifelse(multby2, 
           2*(a*b + k), 
           altmult*(a*b + k)
           )
}
cond5(5, 7, 1:3)
cond5(3:7, 5, 1)
cond5(3:7, 5, 1:5)
cond5(k=1:5, 3:7, 5)
cond5(k=1:5, 3:7, 5, multby2=FALSE)
cond5(k=1:5, 3:7, 5, multby2=FALSE, altmult=5)

@ 

\subsubsection{Why Worry About Vectorization?}

R provides looping constructs and \lstinline{apply} functions. It
might seem that it's not necessary to worry about vectorization. There
are two reasons that I choose to vectorize where feasible.

First, I personally find vectorization convenient and transparent. I
find vectorized code easier to read and it fits the way I like to
work. This is an aesthetic argument.

Second, in my experience the apply functions are a real hurdle for new
R users. Automatic vectorization makes it possible to perform
complicated calculations in a straightforward and intuitive way.

\clearpage

\section{Bibliography}
\bibliographystyle{book2}
%\bibliography{rmcd, derivmkts}
\bibliography{derivmkts}



\end{document}
